# Makefile for enhanced Canny with adaptive thresholding and batch processing

# Location of the CUDA Toolkit
CUDA_PATH ?= /usr/local/cuda-10.0

# architecture
HOST_ARCH   := $(shell uname -m)
TARGET_ARCH ?= x86_64
TARGET_SIZE := 64

# operating system
HOST_OS   := $(shell uname -s 2>/dev/null | tr "[:upper:]" "[:lower:]")
TARGET_OS ?= $(HOST_OS)

ifneq (${TARGET_ARCH},${HOST_ARCH})
	ifeq (${TARGET_ARCH},aarch64)
		HOST_COMPILER ?= aarch64-linux-gnu-g++
	endif
endif

HOST_COMPILER ?= g++
NVCC          := $(CUDA_PATH)/bin/nvcc -ccbin $(HOST_COMPILER)

# internal flags
NVCCFLAGS   := -m${TARGET_SIZE}
CCFLAGS     := -fPIC
LDFLAGS     :=

# build flags
ifneq ($(TARGET_ARCH),$(HOST_ARCH))
    ifeq ($(TARGET_ARCH)-$(TARGET_OS),aarch64-linux)
        ifneq ($(TARGET_FS),)
            GCCVERSIONLTEQ46 := $(shell expr `$(HOST_COMPILER) -dumpversion` \<= 4.6)
            ifeq ($(GCCVERSIONLTEQ46),1)
                CCFLAGS += --sysroot=$(TARGET_FS)
            endif
            LDFLAGS += --sysroot=$(TARGET_FS)
            LDFLAGS += -rpath-link=$(TARGET_FS)/lib -L $(TARGET_FS)/lib
            LDFLAGS += -rpath-link=$(TARGET_FS)/usr/lib -L $(TARGET_FS)/usr/lib
            LDFLAGS += -rpath-link=$(TARGET_FS)/usr/lib/aarch64-linux-gnu -L $(TARGET_FS)/usr/lib/aarch64-linux-gnu
            LDFLAGS += --unresolved-symbols=ignore-in-shared-libs
            CCFLAGS += -isystem=$(TARGET_FS)/usr/include
            CCFLAGS += -isystem=$(TARGET_FS)/usr/include/aarch64-linux-gnu
        endif
    endif
endif

# Debug build flags
ifeq ($(dbg),1)
      NVCCFLAGS += -g -G
      BUILD_TYPE := debug
else
      BUILD_TYPE := release
endif

ALL_CCFLAGS := $(shell pkg-config --libs --cflags libpng)
ALL_CCFLAGS += $(NVCCFLAGS)
ALL_CCFLAGS += $(EXTRA_NVCCFLAGS)
ALL_CCFLAGS += $(addprefix -Xcompiler ,$(CCFLAGS))
ALL_CCFLAGS += $(addprefix -Xcompiler ,$(EXTRA_CCFLAGS))

ALL_LDFLAGS :=
ALL_LDFLAGS += $(ALL_CCFLAGS)
ALL_LDFLAGS += $(addprefix -Xlinker ,$(LDFLAGS))
ALL_LDFLAGS += $(addprefix -Xlinker ,$(EXTRA_LDFLAGS))

# Common includes and paths for CUDA
INCLUDES  := -I${CUDA_PATH}/samples/common/inc
LIBRARIES :=

################################################################################

# Gencode arguments
SMS ?= 53

ifeq ($(GENCODE_FLAGS),)
# Generate SASS code for each SM architecture listed in $(SMS)
$(foreach sm,$(SMS),$(eval GENCODE_FLAGS += -gencode arch=compute_$(sm),code=sm_$(sm)))

# Generate PTX code from the highest SM architecture in $(SMS)
HIGHEST_SM := $(lastword $(sort $(SMS)))
ifneq ($(HIGHEST_SM),)
GENCODE_FLAGS += -gencode arch=compute_$(HIGHEST_SM),code=compute_$(HIGHEST_SM)
endif
endif

################################################################################

# Enhanced version binaries
BINARY_ENHANCED := canny_enhanced
BINARY_ORIGINAL := canny

# Source files for enhanced version
SOURCES_ENHANCED := canny_enhanced.cu adaptive_threshold.cu \
                    enhanced_logging.cu parallel_pipeline.cu \
                    canny_core.cu blur.cu conv2d.cu gray.cu image_prep.cu clock.cu

# C++ support files
CPP_SOURCES := batch_processor.cpp hybrid_scheduler.cpp

# Object files
OBJECTS_ENHANCED := $(SOURCES_ENHANCED:%.cu=%.o)
CPP_OBJECTS := $(CPP_SOURCES:%.cpp=%.o)

# Original source files
SOURCES_ORIGINAL := $(shell find *.cu 2>/dev/null | grep -v enhanced | grep -v adaptive | grep -v parallel | grep -v logging)
OBJECTS_ORIGINAL := $(filter-out $(OBJECTS_ENHANCED) $(CPP_OBJECTS), $(SOURCES_ORIGINAL:%.cu=%.o))

################################################################################

# Target rules
.PHONY: all enhanced original clean

all: enhanced original

enhanced: $(BINARY_ENHANCED)

original: $(BINARY_ORIGINAL)

# Compile CUDA source files
%.o: %.cu
	$(NVCC) $(INCLUDES) $(ALL_CCFLAGS) $(GENCODE_FLAGS) -o $@ -c $<

# Compile C++ source files
%.o: %.cpp
	$(NVCC) $(INCLUDES) $(ALL_CCFLAGS) -x c++ -o $@ -c $<

# Link enhanced version
$(BINARY_ENHANCED): $(OBJECTS_ENHANCED) $(CPP_OBJECTS)
	$(NVCC) $(ALL_LDFLAGS) $(GENCODE_FLAGS) -o $@ $+ $(LIBRARIES)
	@echo "Enhanced binary built successfully!"

# Link original version
$(BINARY_ORIGINAL): canny.o blur.o conv2d.o gray.o image_prep.o clock.o
	$(NVCC) $(ALL_LDFLAGS) $(GENCODE_FLAGS) -o $@ $+ $(LIBRARIES)
	@echo "Original binary built successfully!"

clean:
	rm -f $(BINARY_ENHANCED) $(BINARY_ORIGINAL) *.o
	@echo "Cleaned build artifacts"

help:
	@echo "Enhanced CUDA Canny Makefile"
	@echo ""
	@echo "Targets:"
	@echo "  all       - Build both enhanced and original versions"
	@echo "  enhanced  - Build only enhanced version with all features"
	@echo "  original  - Build only original version"
	@echo "  clean     - Remove all build artifacts"
	@echo ""
	@echo "Build flags:"
	@echo "  dbg=1           - Enable debug build"
	@echo "  CUDA_PATH=...   - Specify CUDA installation path"
	@echo "  TARGET_ARCH=... - Specify target architecture (x86_64 or aarch64)"
	@echo "  SMS=...         - Specify compute capability (default: 53)"
	@echo ""
	@echo "Example:"
	@echo "  make -f Makefile.enhanced enhanced CUDA_PATH=/usr TARGET_ARCH=x86_64 SMS=30"
